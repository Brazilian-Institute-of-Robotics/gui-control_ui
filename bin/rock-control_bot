#! /usr/bin/env ruby

require 'vizkit'
require 'optparse'
require 'pry'

use_test_gui = true
hostname = nil
do_read=true
do_write=true
only_positive=false
override_vel_limits=0.0
no_effort=false
no_velocity=false
@force_cmd_port=""
@force_state_port=""
options = OptionParser.new do |opt|
    opt.banner = <<-EOD
rock-control_bot [options] /path/to/model/file [task context to write joint commands to]
    EOD
    opt.on '--host=HOSTNAME', String, 'the host we should contact to find RTT tasks' do |host|
        hostname = host
    end
    opt.on '--help', 'this help message' do
        puts opt
        exit(0)
    end
    opt.on '--dont_read', "Don't read joint state from provided task context." do
        do_read=false
    end
    opt.on '--dont_write', "Don't write joint commands to provided task context." do
        do_write=false
    end
    opt.on '--only_positive_vel', "Use only positive velocities for sending" do
        only_positive=true
    end
    opt.on '--override_vel_limits=VALUE', "Oerrride velocity limits with the value given (positive and negative limits are changed to this value)" do |val|
        override_vel_limits=Float(val)
    end
    opt.on '--no_effort', "Don't generate UI elements for effort" do
        no_effort=true
    end
    opt.on '--no_velocity', "Don't generate UI elements for velocity" do
        no_velocity=true
    end
    opt.on '--joint_command_port=PORT_NAME', '-c=PORT_NAME' , "Force joint command port to be PORT NAME" do |val|
        puts "Will take port '#{val}' for writing commands to"
        @force_cmd_port = val.dup
    end
    opt.on '--joint_state_port=PORT_NAME', '-s=PORT_NAME' , "Force joint state port to be PORT NAME" do |val|
        puts "Will take port '#{val}' for reading state from"
        @force_state_port = val.dup
    end
end

args = options.parse(ARGV)
model_file = args.shift
task_context_name = args.shift

if !model_file
    puts "missing model file argument"
    puts options
    exit 1
end

if task_context_name
    if hostname
        Orocos::CORBA.name_service.ip = hostname
    end
    Orocos.initialize
    Orocos.load_typekit('base')
else
    puts "No task context was given!"
end

ctrl_gui = Vizkit.default_loader.ControlUi
ctrl_gui.configureUi(override_vel_limits, only_positive, no_effort, no_velocity)

yaml_file_ext = [".yml", ".yaml"]
urdf_file_ext = [".urdf", ".xml"]

if yaml_file_ext.include? File.extname(model_file)
    ctrl_gui.initFromYaml(model_file.dup)
elsif urdf_file_ext.include? File.extname(model_file)
    ctrl_gui.initFromURDF(model_file.dup)
else
    print "Invalid model file format. Accepts only ", yaml_file_ext, " or ", urdf_file_ext
end
    
if task_context_name
    control = Orocos::Async.name_service.get task_context_name

    if do_write
        #Determine input port name
        port_name = ""
        if @force_cmd_port == ""
            matching_ports = control.ports.find_all {|p| p.is_a? Orocos::InputPort and p.type == Types::Base::Commands::Joints}
            if matching_ports.size > 1
              puts "Multiple joint command consumer ports. Don't know which to use."
              matching_ports.each { |p| puts p.name }
            
              exit 1
            end
            if matching_ports.size < 1 
                puts "No joint command consumer port available."
                exit 1
            end
            port_name = matching_ports[0].name
        else
            puts "Joint state port was forced to be '#{@force_cmd_port}'"
            port_name = @force_cmd_port
        end
        
        #Create writer
        port = control.port(port_name)
        puts port
        if not port
           puts "Port #{port_name} could not be found on task #{task_context_name}"
           exit 1
        end
        writer = port.writer

        #Connect to gui
        ctrl_gui.connect(SIGNAL('sendSignal()')) do 
            sample = ctrl_gui.getJoints()
            ret = writer.write(sample)
        end
    end

    
    if do_read
        #Determine output port name
        port_name = ""
        if @force_state_port == ""
            matching_ports = control.ports.find_all {|p| p.is_a? Orocos::OutputPort and p.type == Types::Base::Samples::Joints}
            if matching_ports.size > 1
              puts "Multiple joint state producer ports. Don't know which to use."
              matching_ports.each { |p| puts p.name }
              exit 1
            end
            if matching_ports.size < 1 
                puts "No joint command consumer port available."
                exit 1
            end
            port_name = matching_ports[0].name
        else
            port_name = @force_state_port
            puts "Joint command port was forced to be '#{@force_state_port}'"
        end
        state_port = control.port(port_name)

        if not state_port
           puts "Port #{port_name} could not be found on task #{task_context_name}"
           exit 1
        end

        state_port.on_data do |data| 
             ctrl_gui.setJointState(data)
        end
    end
end
Vizkit.exec    
    
