#! /usr/bin/env ruby

require 'vizkit'
require 'optparse'
require 'pry'

use_test_gui = true
hostname = nil
do_read=true
do_write=true
only_positive=false
override_vel_limits=0.0
no_effort=false
no_velocity=false
@force_cmd_port=""
@force_state_port=""
options = OptionParser.new do |opt|
    opt.banner = <<-EOD
rock-control_bot [options] /path/to/model/file [task context to write joint commands to]
    EOD
    opt.on '--host=HOSTNAME', String, 'the host we should contact to find RTT tasks' do |host|
        hostname = host
    end
    opt.on '--help', 'this help message' do
        puts opt
        exit(0)
    end
    opt.on '--dont_read', "Don't read joint state from provided task context." do
        do_read=false
    end
    opt.on '--dont_write', "Don't write joint commands to provided task context." do
        do_write=false
    end
    opt.on '--only_positive_vel', "Use only positive velocities for sending" do
        only_positive=true
    end
    opt.on '--override_vel_limits=VALUE', "Oerrride velocity limits with the value given (positive and negative limits are changed to this value)" do |val|
        override_vel_limits=Float(val)
    end
    opt.on '--no_effort', "Don't generate UI elements for effort" do
        no_effort=true
    end
    opt.on '--no_velocity', "Don't generate UI elements for velocity" do
        no_velocity=true
    end
    opt.on '--joint_command_port=PORT_NAME', '-c=PORT_NAME' , "Force joint command port to be PORT NAME" do |val|
        puts "Will take port '#{val}' for writing commands to"
        @force_cmd_port = val.dup
    end
    opt.on '--joint_state_port=PORT_NAME', '-s=PORT_NAME' , "Force joint state port to be PORT NAME" do |val|
        puts "Will take port '#{val}' for reading state from"
        @force_state_port = val.dup
    end
end

args = options.parse(ARGV)
model_file = args.shift
task_context_name = args.shift

if !model_file
    puts "missing model file argument"
    puts options
    exit 1
end

if task_context_name
    if hostname
        Orocos::CORBA.name_service.ip = hostname
    end
    Orocos.initialize
end

ctrl_gui = Vizkit.default_loader.ControlUi
ctrl_gui.configureUi(override_vel_limits, only_positive, no_effort, no_velocity)
ctrl_gui.initModel(model_file.dup)
    
if task_context_name
    control = Orocos::Async.name_service.get task_context_name

    #find commands input port
    if do_write
        if @force_cmd_port == ""
            matching_ports = control.ports.find_all {|p| p.is_a? Orocos::InputPort and p.type == Types::Base::Commands::Joints}
            if matching_ports.size > 1
              puts "Multiple joint command consumer ports. Don't know which to use."
              matching_ports.each { |p| puts p.name }
            
              exit 1
            end
            if matching_ports.size < 1 
                puts "No joint command consumer port available."
                exit 1
            end
            writer = matching_ports[0].writer
        else
            port = control.port(@force_cmd_port)
            puts port
            if not port
               puts "Joint state port was forced to be '#{@force_cmd_port}' but could not be found on task #{task_context_name}"
               exit 1
            end
            writer = port.writer
        end
        ctrl_gui.connect(SIGNAL('sendSignal()')) do 
            sample = ctrl_gui.getJoints()
            ret = writer.write(sample)
        end
    end

    #find state output port
    if do_read
        state_port = nil
        if @force_state_port == ""
            matching_ports = control.ports.find_all {|p| p.is_a? Orocos::OutputPort and p.type == Types::Base::Samples::Joints}
            if matching_ports.size > 1
              puts "Multiple joint state producer ports. Don't know which to use."
              matching_ports.each { |p| puts p.name }
              exit 1
            end
            if matching_ports.size < 1 
                puts "No joint command consumer port available."
                exit 1
            end
            state_port = matching_ports[0]
        else
            port = control.port(@force_state_port)
            puts port
            if not port
               puts "Joint command port was forced to be '#{@force_state_port}' but could not be found on task #{task_context_name}"
               exit 1
            end
            state_port = port
        end

        state_port.on_data do |data| 
             ctrl_gui.setJointState(data)
        end
    end
end
Vizkit.exec    
    
